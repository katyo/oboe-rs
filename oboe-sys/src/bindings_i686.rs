/* automatically generated by rust-bindgen 0.56.0 */

pub type size_t = ::std::os::raw::c_uint;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub const oboe_StreamState_Uninitialized: oboe_StreamState = 0;
pub const oboe_StreamState_Unknown: oboe_StreamState = 1;
pub const oboe_StreamState_Open: oboe_StreamState = 2;
pub const oboe_StreamState_Starting: oboe_StreamState = 3;
pub const oboe_StreamState_Started: oboe_StreamState = 4;
pub const oboe_StreamState_Pausing: oboe_StreamState = 5;
pub const oboe_StreamState_Paused: oboe_StreamState = 6;
pub const oboe_StreamState_Flushing: oboe_StreamState = 7;
pub const oboe_StreamState_Flushed: oboe_StreamState = 8;
pub const oboe_StreamState_Stopping: oboe_StreamState = 9;
pub const oboe_StreamState_Stopped: oboe_StreamState = 10;
pub const oboe_StreamState_Closing: oboe_StreamState = 11;
pub const oboe_StreamState_Closed: oboe_StreamState = 12;
pub const oboe_StreamState_Disconnected: oboe_StreamState = 13;
#[doc = " The state of the audio stream."]
pub type oboe_StreamState = i32;
#[doc = " Used for playback."]
pub const oboe_Direction_Output: oboe_Direction = 0;
#[doc = " Used for recording."]
pub const oboe_Direction_Input: oboe_Direction = 1;
#[doc = " The direction of the stream."]
pub type oboe_Direction = i32;
#[doc = " Invalid format."]
pub const oboe_AudioFormat_Invalid: oboe_AudioFormat = -1;
#[doc = " Unspecified format. Format will be decided by Oboe."]
pub const oboe_AudioFormat_Unspecified: oboe_AudioFormat = 0;
#[doc = " Signed 16-bit integers."]
pub const oboe_AudioFormat_I16: oboe_AudioFormat = 1;
#[doc = " Single precision floating points."]
pub const oboe_AudioFormat_Float: oboe_AudioFormat = 2;
#[doc = " The format of audio samples."]
pub type oboe_AudioFormat = i32;
pub const oboe_DataCallbackResult_Continue: oboe_DataCallbackResult = 0;
pub const oboe_DataCallbackResult_Stop: oboe_DataCallbackResult = 1;
#[doc = " The result of an audio callback."]
pub type oboe_DataCallbackResult = i32;
pub const oboe_Result_OK: oboe_Result = 0;
pub const oboe_Result_ErrorBase: oboe_Result = -900;
pub const oboe_Result_ErrorDisconnected: oboe_Result = -899;
pub const oboe_Result_ErrorIllegalArgument: oboe_Result = -898;
pub const oboe_Result_ErrorInternal: oboe_Result = -896;
pub const oboe_Result_ErrorInvalidState: oboe_Result = -895;
pub const oboe_Result_ErrorInvalidHandle: oboe_Result = -892;
pub const oboe_Result_ErrorUnimplemented: oboe_Result = -890;
pub const oboe_Result_ErrorUnavailable: oboe_Result = -889;
pub const oboe_Result_ErrorNoFreeHandles: oboe_Result = -888;
pub const oboe_Result_ErrorNoMemory: oboe_Result = -887;
pub const oboe_Result_ErrorNull: oboe_Result = -886;
pub const oboe_Result_ErrorTimeout: oboe_Result = -885;
pub const oboe_Result_ErrorWouldBlock: oboe_Result = -884;
pub const oboe_Result_ErrorInvalidFormat: oboe_Result = -883;
pub const oboe_Result_ErrorOutOfRange: oboe_Result = -882;
pub const oboe_Result_ErrorNoService: oboe_Result = -881;
pub const oboe_Result_ErrorInvalidRate: oboe_Result = -880;
pub const oboe_Result_Reserved1: oboe_Result = -879;
pub const oboe_Result_Reserved2: oboe_Result = -878;
pub const oboe_Result_Reserved3: oboe_Result = -877;
pub const oboe_Result_Reserved4: oboe_Result = -876;
pub const oboe_Result_Reserved5: oboe_Result = -875;
pub const oboe_Result_Reserved6: oboe_Result = -874;
pub const oboe_Result_Reserved7: oboe_Result = -873;
pub const oboe_Result_Reserved8: oboe_Result = -872;
pub const oboe_Result_Reserved9: oboe_Result = -871;
pub const oboe_Result_Reserved10: oboe_Result = -870;
pub const oboe_Result_ErrorClosed: oboe_Result = -869;
#[doc = " The result of an operation. All except the `OK` result indicates that an error occurred."]
#[doc = " The `Result` can be converted into a human readable string using `convertToText`."]
pub type oboe_Result = i32;
#[doc = " This will be the only stream using a particular source or sink."]
#[doc = " This mode will provide the lowest possible latency."]
#[doc = " You should close EXCLUSIVE streams immediately when you are not using them."]
#[doc = ""]
#[doc = " If you do not need the lowest possible latency then we recommend using Shared,"]
#[doc = " which is the default."]
pub const oboe_SharingMode_Exclusive: oboe_SharingMode = 0;
#[doc = " Multiple applications can share the same device."]
#[doc = " The data from output streams will be mixed by the audio service."]
#[doc = " The data for input streams will be distributed by the audio service."]
#[doc = ""]
#[doc = " This will have higher latency than the EXCLUSIVE mode."]
pub const oboe_SharingMode_Shared: oboe_SharingMode = 1;
#[doc = " The sharing mode of the audio stream."]
pub type oboe_SharingMode = i32;
#[doc = " No particular performance needs. Default."]
pub const oboe_PerformanceMode_None: oboe_PerformanceMode = 10;
#[doc = " Extending battery life is most important."]
pub const oboe_PerformanceMode_PowerSaving: oboe_PerformanceMode = 11;
#[doc = " Reducing latency is most important."]
pub const oboe_PerformanceMode_LowLatency: oboe_PerformanceMode = 12;
#[doc = " The performance mode of the audio stream."]
pub type oboe_PerformanceMode = i32;
#[doc = " Try to use AAudio. If not available then use OpenSL ES."]
pub const oboe_AudioApi_Unspecified: oboe_AudioApi = 0;
#[doc = " Use OpenSL ES."]
pub const oboe_AudioApi_OpenSLES: oboe_AudioApi = 1;
#[doc = " Try to use AAudio. Fail if unavailable."]
pub const oboe_AudioApi_AAudio: oboe_AudioApi = 2;
#[doc = " The underlying audio API used by the audio stream."]
pub type oboe_AudioApi = i32;
#[doc = " No conversion by Oboe. Underlying APIs may still do conversion."]
pub const oboe_SampleRateConversionQuality_None: oboe_SampleRateConversionQuality = 0;
#[doc = " Fastest conversion but may not sound great."]
#[doc = " This may be implemented using bilinear interpolation."]
pub const oboe_SampleRateConversionQuality_Fastest: oboe_SampleRateConversionQuality = 1;
#[doc = " Fastest conversion but may not sound great."]
#[doc = " This may be implemented using bilinear interpolation."]
pub const oboe_SampleRateConversionQuality_Low: oboe_SampleRateConversionQuality = 2;
#[doc = " Fastest conversion but may not sound great."]
#[doc = " This may be implemented using bilinear interpolation."]
pub const oboe_SampleRateConversionQuality_Medium: oboe_SampleRateConversionQuality = 3;
#[doc = " Fastest conversion but may not sound great."]
#[doc = " This may be implemented using bilinear interpolation."]
pub const oboe_SampleRateConversionQuality_High: oboe_SampleRateConversionQuality = 4;
#[doc = " Highest quality conversion, which may be expensive in terms of CPU."]
pub const oboe_SampleRateConversionQuality_Best: oboe_SampleRateConversionQuality = 5;
#[doc = " Specifies the quality of the sample rate conversion performed by Oboe."]
#[doc = " Higher quality will require more CPU load."]
#[doc = " Higher quality conversion will probably be implemented using a sinc based resampler."]
pub type oboe_SampleRateConversionQuality = i32;
#[doc = " Use this for streaming media, music performance, video, podcasts, etcetera."]
pub const oboe_Usage_Media: oboe_Usage = 1;
#[doc = " Use this for voice over IP, telephony, etcetera."]
pub const oboe_Usage_VoiceCommunication: oboe_Usage = 2;
#[doc = " Use this for sounds associated with telephony such as busy tones, DTMF, etcetera."]
pub const oboe_Usage_VoiceCommunicationSignalling: oboe_Usage = 3;
#[doc = " Use this to demand the users attention."]
pub const oboe_Usage_Alarm: oboe_Usage = 4;
#[doc = " Use this for notifying the user when a message has arrived or some"]
#[doc = " other background event has occured."]
pub const oboe_Usage_Notification: oboe_Usage = 5;
#[doc = " Use this when the phone rings."]
pub const oboe_Usage_NotificationRingtone: oboe_Usage = 6;
#[doc = " Use this to attract the users attention when, for example, the battery is low."]
pub const oboe_Usage_NotificationEvent: oboe_Usage = 10;
#[doc = " Use this for screen readers, etcetera."]
pub const oboe_Usage_AssistanceAccessibility: oboe_Usage = 11;
#[doc = " Use this for driving or navigation directions."]
pub const oboe_Usage_AssistanceNavigationGuidance: oboe_Usage = 12;
#[doc = " Use this for user interface sounds, beeps, etcetera."]
pub const oboe_Usage_AssistanceSonification: oboe_Usage = 13;
#[doc = " Use this for game audio and sound effects."]
pub const oboe_Usage_Game: oboe_Usage = 14;
#[doc = " Use this for audio responses to user queries, audio instructions or help utterances."]
pub const oboe_Usage_Assistant: oboe_Usage = 16;
#[doc = " The Usage attribute expresses *why* you are playing a sound, what is this sound used for."]
#[doc = " This information is used by certain platforms or routing policies"]
#[doc = " to make more refined volume or routing decisions."]
#[doc = ""]
#[doc = " Note that these match the equivalent values in AudioAttributes in the Android Java API."]
#[doc = ""]
#[doc = " This attribute only has an effect on Android API 28+."]
pub type oboe_Usage = i32;
#[doc = " Use this for spoken voice, audio books, etcetera."]
pub const oboe_ContentType_Speech: oboe_ContentType = 1;
#[doc = " Use this for pre-recorded or live music."]
pub const oboe_ContentType_Music: oboe_ContentType = 2;
#[doc = " Use this for a movie or video soundtrack."]
pub const oboe_ContentType_Movie: oboe_ContentType = 3;
#[doc = " Use this for sound is designed to accompany a user action,"]
#[doc = " such as a click or beep sound made when the user presses a button."]
pub const oboe_ContentType_Sonification: oboe_ContentType = 4;
#[doc = " The ContentType attribute describes *what* you are playing."]
#[doc = " It expresses the general category of the content. This information is optional."]
#[doc = " But in case it is known (for instance {@link Movie} for a"]
#[doc = " movie streaming service or {@link Speech} for"]
#[doc = " an audio book application) this information might be used by the audio framework to"]
#[doc = " enforce audio focus."]
#[doc = ""]
#[doc = " Note that these match the equivalent values in AudioAttributes in the Android Java API."]
#[doc = ""]
#[doc = " This attribute only has an effect on Android API 28+."]
pub type oboe_ContentType = i32;
#[doc = " Use this preset when other presets do not apply."]
pub const oboe_InputPreset_Generic: oboe_InputPreset = 1;
#[doc = " Use this preset when recording video."]
pub const oboe_InputPreset_Camcorder: oboe_InputPreset = 5;
#[doc = " Use this preset when doing speech recognition."]
pub const oboe_InputPreset_VoiceRecognition: oboe_InputPreset = 6;
#[doc = " Use this preset when doing telephony or voice messaging."]
pub const oboe_InputPreset_VoiceCommunication: oboe_InputPreset = 7;
#[doc = " Use this preset to obtain an input with no effects."]
#[doc = " Note that this input will not have automatic gain control"]
#[doc = " so the recorded volume may be very low."]
pub const oboe_InputPreset_Unprocessed: oboe_InputPreset = 9;
#[doc = " Use this preset for capturing audio meant to be processed in real time"]
#[doc = " and played back for live performance (e.g karaoke)."]
#[doc = " The capture path will minimize latency and coupling with playback path."]
pub const oboe_InputPreset_VoicePerformance: oboe_InputPreset = 10;
#[doc = " Defines the audio source."]
#[doc = " An audio source defines both a default physical source of audio signal, and a recording"]
#[doc = " configuration."]
#[doc = ""]
#[doc = " Note that these match the equivalent values in MediaRecorder.AudioSource in the Android Java API."]
#[doc = ""]
#[doc = " This attribute only has an effect on Android API 28+."]
pub type oboe_InputPreset = i32;
#[doc = " Do not allocate a session ID."]
#[doc = " Effects cannot be used with this stream."]
#[doc = " Default."]
pub const oboe_SessionId_None: oboe_SessionId = -1;
#[doc = " Allocate a session ID that can be used to attach and control"]
#[doc = " effects using the Java AudioEffects API."]
#[doc = " Note that the use of this flag may result in higher latency."]
#[doc = ""]
#[doc = " Note that this matches the value of AudioManager.AUDIO_SESSION_ID_GENERATE."]
pub const oboe_SessionId_Allocate: oboe_SessionId = 0;
#[doc = " This attribute can be used to allocate a session ID to the audio stream."]
#[doc = ""]
#[doc = " This attribute only has an effect on Android API 28+."]
pub type oboe_SessionId = ::std::os::raw::c_int;
#[doc = " Audio channel count definition, use Mono or Stereo"]
pub const oboe_ChannelCount_Unspecified: oboe_ChannelCount = 0;
#[doc = " Use this for mono audio"]
pub const oboe_ChannelCount_Mono: oboe_ChannelCount = 1;
#[doc = " Use this for stereo audio."]
pub const oboe_ChannelCount_Stereo: oboe_ChannelCount = 2;
#[doc = " The channel count of the audio stream. The underlying type is `int32_t`."]
#[doc = " Use of this enum is convenient to avoid \"magic\""]
#[doc = " numbers when specifying the channel count."]
#[doc = ""]
#[doc = " For example, you can write"]
#[doc = " `builder.setChannelCount(ChannelCount::Stereo)`"]
#[doc = " rather than `builder.setChannelCount(2)`"]
#[doc = ""]
pub type oboe_ChannelCount = i32;
#[doc = " On API 16 to 26 OpenSL ES will be used. When using OpenSL ES the optimal values for sampleRate and"]
#[doc = " framesPerBurst are not known by the native code."]
#[doc = " On API 17+ these values should be obtained from the AudioManager using this code:"]
#[doc = ""]
#[doc = " <pre><code>"]
#[doc = " // Note that this technique only works for built-in speakers and headphones."]
#[doc = " AudioManager myAudioMgr = (AudioManager) getSystemService(Context.AUDIO_SERVICE);"]
#[doc = " String sampleRateStr = myAudioMgr.getProperty(AudioManager.PROPERTY_OUTPUT_SAMPLE_RATE);"]
#[doc = " int defaultSampleRate = Integer.parseInt(sampleRateStr);"]
#[doc = " String framesPerBurstStr = myAudioMgr.getProperty(AudioManager.PROPERTY_OUTPUT_FRAMES_PER_BUFFER);"]
#[doc = " int defaultFramesPerBurst = Integer.parseInt(framesPerBurstStr);"]
#[doc = " </code></pre>"]
#[doc = ""]
#[doc = " It can then be passed down to Oboe through JNI."]
#[doc = ""]
#[doc = " AAudio will get the optimal framesPerBurst from the HAL and will ignore this value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct oboe_DefaultStreamValues {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}_ZN4oboe19DefaultStreamValues10SampleRateE"]
    pub static mut oboe_DefaultStreamValues_SampleRate: i32;
}
extern "C" {
    #[link_name = "\u{1}_ZN4oboe19DefaultStreamValues14FramesPerBurstE"]
    pub static mut oboe_DefaultStreamValues_FramesPerBurst: i32;
}
extern "C" {
    #[link_name = "\u{1}_ZN4oboe19DefaultStreamValues12ChannelCountE"]
    pub static mut oboe_DefaultStreamValues_ChannelCount: i32;
}
#[test]
fn bindgen_test_layout_oboe_DefaultStreamValues() {
    assert_eq!(
        ::std::mem::size_of::<oboe_DefaultStreamValues>(),
        1usize,
        concat!("Size of: ", stringify!(oboe_DefaultStreamValues))
    );
    assert_eq!(
        ::std::mem::align_of::<oboe_DefaultStreamValues>(),
        1usize,
        concat!("Alignment of ", stringify!(oboe_DefaultStreamValues))
    );
}
#[doc = " The time at which the frame at `position` was presented"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct oboe_FrameTimestamp {
    pub position: i64,
    pub timestamp: i64,
}
#[test]
fn bindgen_test_layout_oboe_FrameTimestamp() {
    assert_eq!(
        ::std::mem::size_of::<oboe_FrameTimestamp>(),
        16usize,
        concat!("Size of: ", stringify!(oboe_FrameTimestamp))
    );
    assert_eq!(
        ::std::mem::align_of::<oboe_FrameTimestamp>(),
        4usize,
        concat!("Alignment of ", stringify!(oboe_FrameTimestamp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<oboe_FrameTimestamp>())).position as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(oboe_FrameTimestamp),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<oboe_FrameTimestamp>())).timestamp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(oboe_FrameTimestamp),
            "::",
            stringify!(timestamp)
        )
    );
}
#[doc = " A ResultWithValue can store both the result of an operation (either OK or an error) and a value."]
#[doc = ""]
#[doc = " It has been designed for cases where the caller needs to know whether an operation succeeded and,"]
#[doc = " if it did, a value which was obtained during the operation."]
#[doc = ""]
#[doc = " For example, when reading from a stream the caller needs to know the result of the read operation"]
#[doc = " and, if it was successful, how many frames were read. Note that ResultWithValue can be evaluated"]
#[doc = " as a boolean so it's simple to check whether the result is OK."]
#[doc = ""]
#[doc = " <code>"]
#[doc = " ResultWithValue<int32_t> resultOfRead = myStream.read(&buffer, numFrames, timeoutNanoseconds);"]
#[doc = ""]
#[doc = " if (resultOfRead) {"]
#[doc = "     LOGD(\"Frames read: %d\", resultOfRead.value());"]
#[doc = " } else {"]
#[doc = "     LOGD(\"Error reading from stream: %s\", resultOfRead.error());"]
#[doc = " }"]
#[doc = " </code>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct oboe_ResultWithValue<T> {
    pub mValue: T,
    pub mError: oboe_Result,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
#[repr(C)]
pub struct oboe_AudioStreamDataCallback__bindgen_vtable(::std::os::raw::c_void);
#[doc = " AudioStreamDataCallback defines a callback interface for"]
#[doc = " moving data to/from an audio stream using `onAudioReady`"]
#[doc = " 2) being alerted when a stream has an error using `onError*` methods"]
#[doc = ""]
#[doc = " It is used with AudioStreamBuilder::setDataCallback()."]
#[repr(C)]
#[derive(Debug)]
pub struct oboe_AudioStreamDataCallback {
    pub vtable_: *const oboe_AudioStreamDataCallback__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_oboe_AudioStreamDataCallback() {
    assert_eq!(
        ::std::mem::size_of::<oboe_AudioStreamDataCallback>(),
        4usize,
        concat!("Size of: ", stringify!(oboe_AudioStreamDataCallback))
    );
    assert_eq!(
        ::std::mem::align_of::<oboe_AudioStreamDataCallback>(),
        4usize,
        concat!("Alignment of ", stringify!(oboe_AudioStreamDataCallback))
    );
}
#[repr(C)]
pub struct oboe_AudioStreamErrorCallback__bindgen_vtable(::std::os::raw::c_void);
#[doc = " AudioStreamErrorCallback defines a callback interface for"]
#[doc = " being alerted when a stream has an error or is disconnected"]
#[doc = " using `onError*` methods."]
#[doc = ""]
#[doc = " It is used with AudioStreamBuilder::setErrorCallback()."]
#[repr(C)]
#[derive(Debug)]
pub struct oboe_AudioStreamErrorCallback {
    pub vtable_: *const oboe_AudioStreamErrorCallback__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_oboe_AudioStreamErrorCallback() {
    assert_eq!(
        ::std::mem::size_of::<oboe_AudioStreamErrorCallback>(),
        4usize,
        concat!("Size of: ", stringify!(oboe_AudioStreamErrorCallback))
    );
    assert_eq!(
        ::std::mem::align_of::<oboe_AudioStreamErrorCallback>(),
        4usize,
        concat!("Alignment of ", stringify!(oboe_AudioStreamErrorCallback))
    );
}
#[doc = " AudioStreamCallback defines a callback interface for:"]
#[doc = ""]
#[doc = " 1) moving data to/from an audio stream using `onAudioReady`"]
#[doc = " 2) being alerted when a stream has an error using `onError*` methods"]
#[doc = ""]
#[doc = " It is used with AudioStreamBuilder::setCallback()."]
#[doc = ""]
#[doc = " It combines the interfaces defined by AudioStreamDataCallback and AudioStreamErrorCallback."]
#[doc = " This was the original callback object. We now recommend using the individual interfaces"]
#[doc = " and using setDataCallback() and setErrorCallback()."]
#[doc = ""]
#[doc = " @deprecated Use `AudioStreamDataCallback` and `AudioStreamErrorCallback` instead"]
#[repr(C)]
#[derive(Debug)]
pub struct oboe_AudioStreamCallback {
    pub _base: oboe_AudioStreamDataCallback,
    pub _base_1: oboe_AudioStreamErrorCallback,
}
#[test]
fn bindgen_test_layout_oboe_AudioStreamCallback() {
    assert_eq!(
        ::std::mem::size_of::<oboe_AudioStreamCallback>(),
        8usize,
        concat!("Size of: ", stringify!(oboe_AudioStreamCallback))
    );
    assert_eq!(
        ::std::mem::align_of::<oboe_AudioStreamCallback>(),
        4usize,
        concat!("Alignment of ", stringify!(oboe_AudioStreamCallback))
    );
}
#[repr(C)]
pub struct oboe_AudioStreamBase__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Base class containing parameters for audio streams and builders."]
#[repr(C)]
#[derive(Debug)]
pub struct oboe_AudioStreamBase {
    pub vtable_: *const oboe_AudioStreamBase__bindgen_vtable,
    #[doc = " The callback which will be fired when new data is ready to be read/written."]
    pub mDataCallback: *mut oboe_AudioStreamDataCallback,
    #[doc = " The callback which will be fired when an error or a disconnect occurs."]
    pub mErrorCallback: *mut oboe_AudioStreamErrorCallback,
    #[doc = " Number of audio frames which will be requested in each callback"]
    pub mFramesPerCallback: i32,
    #[doc = " Stream channel count"]
    pub mChannelCount: i32,
    #[doc = " Stream sample rate"]
    pub mSampleRate: i32,
    #[doc = " Stream audio device ID"]
    pub mDeviceId: i32,
    #[doc = " Stream buffer capacity specified as a number of audio frames"]
    pub mBufferCapacityInFrames: i32,
    #[doc = " Stream buffer size specified as a number of audio frames"]
    pub mBufferSizeInFrames: i32,
    #[doc = " Number of frames which will be copied to/from the audio device in a single read/write"]
    #[doc = " operation"]
    pub mFramesPerBurst: i32,
    #[doc = " Stream sharing mode"]
    pub mSharingMode: oboe_SharingMode,
    #[doc = " Format of audio frames"]
    pub mFormat: oboe_AudioFormat,
    #[doc = " Stream direction"]
    pub mDirection: oboe_Direction,
    #[doc = " Stream performance mode"]
    pub mPerformanceMode: oboe_PerformanceMode,
    #[doc = " Stream usage. Only active on Android 28+"]
    pub mUsage: oboe_Usage,
    #[doc = " Stream content type. Only active on Android 28+"]
    pub mContentType: oboe_ContentType,
    #[doc = " Stream input preset. Only active on Android 28+"]
    #[doc = " TODO InputPreset::Unspecified should be considered as a possible default alternative."]
    pub mInputPreset: oboe_InputPreset,
    #[doc = " Stream session ID allocation strategy. Only active on Android 28+"]
    pub mSessionId: oboe_SessionId,
    pub mChannelConversionAllowed: bool,
    pub mFormatConversionAllowed: bool,
    pub mSampleRateConversionQuality: oboe_SampleRateConversionQuality,
}
#[test]
fn bindgen_test_layout_oboe_AudioStreamBase() {
    assert_eq!(
        ::std::mem::size_of::<oboe_AudioStreamBase>(),
        80usize,
        concat!("Size of: ", stringify!(oboe_AudioStreamBase))
    );
    assert_eq!(
        ::std::mem::align_of::<oboe_AudioStreamBase>(),
        4usize,
        concat!("Alignment of ", stringify!(oboe_AudioStreamBase))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<oboe_AudioStreamBase>())).mDataCallback as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(oboe_AudioStreamBase),
            "::",
            stringify!(mDataCallback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<oboe_AudioStreamBase>())).mErrorCallback as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(oboe_AudioStreamBase),
            "::",
            stringify!(mErrorCallback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<oboe_AudioStreamBase>())).mFramesPerCallback as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(oboe_AudioStreamBase),
            "::",
            stringify!(mFramesPerCallback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<oboe_AudioStreamBase>())).mChannelCount as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(oboe_AudioStreamBase),
            "::",
            stringify!(mChannelCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<oboe_AudioStreamBase>())).mSampleRate as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(oboe_AudioStreamBase),
            "::",
            stringify!(mSampleRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<oboe_AudioStreamBase>())).mDeviceId as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(oboe_AudioStreamBase),
            "::",
            stringify!(mDeviceId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<oboe_AudioStreamBase>())).mBufferCapacityInFrames as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(oboe_AudioStreamBase),
            "::",
            stringify!(mBufferCapacityInFrames)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<oboe_AudioStreamBase>())).mBufferSizeInFrames as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(oboe_AudioStreamBase),
            "::",
            stringify!(mBufferSizeInFrames)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<oboe_AudioStreamBase>())).mFramesPerBurst as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(oboe_AudioStreamBase),
            "::",
            stringify!(mFramesPerBurst)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<oboe_AudioStreamBase>())).mSharingMode as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(oboe_AudioStreamBase),
            "::",
            stringify!(mSharingMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<oboe_AudioStreamBase>())).mFormat as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(oboe_AudioStreamBase),
            "::",
            stringify!(mFormat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<oboe_AudioStreamBase>())).mDirection as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(oboe_AudioStreamBase),
            "::",
            stringify!(mDirection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<oboe_AudioStreamBase>())).mPerformanceMode as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(oboe_AudioStreamBase),
            "::",
            stringify!(mPerformanceMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<oboe_AudioStreamBase>())).mUsage as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(oboe_AudioStreamBase),
            "::",
            stringify!(mUsage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<oboe_AudioStreamBase>())).mContentType as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(oboe_AudioStreamBase),
            "::",
            stringify!(mContentType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<oboe_AudioStreamBase>())).mInputPreset as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(oboe_AudioStreamBase),
            "::",
            stringify!(mInputPreset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<oboe_AudioStreamBase>())).mSessionId as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(oboe_AudioStreamBase),
            "::",
            stringify!(mSessionId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<oboe_AudioStreamBase>())).mChannelConversionAllowed as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(oboe_AudioStreamBase),
            "::",
            stringify!(mChannelConversionAllowed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<oboe_AudioStreamBase>())).mFormatConversionAllowed as *const _
                as usize
        },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(oboe_AudioStreamBase),
            "::",
            stringify!(mFormatConversionAllowed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<oboe_AudioStreamBase>())).mSampleRateConversionQuality
                as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(oboe_AudioStreamBase),
            "::",
            stringify!(mSampleRateConversionQuality)
        )
    );
}
#[doc = " Factory class for an audio Stream."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct oboe_AudioStreamBuilder {
    pub _bindgen_opaque_blob: [u32; 21usize],
}
#[test]
fn bindgen_test_layout_oboe_AudioStreamBuilder() {
    assert_eq!(
        ::std::mem::size_of::<oboe_AudioStreamBuilder>(),
        84usize,
        concat!("Size of: ", stringify!(oboe_AudioStreamBuilder))
    );
    assert_eq!(
        ::std::mem::align_of::<oboe_AudioStreamBuilder>(),
        4usize,
        concat!("Alignment of ", stringify!(oboe_AudioStreamBuilder))
    );
}
extern "C" {
    #[doc = " Is the AAudio API supported on this device?"]
    #[doc = ""]
    #[doc = " AAudio was introduced in the Oreo 8.0 release."]
    #[doc = ""]
    #[doc = " @return true if supported"]
    #[link_name = "\u{1}_ZN4oboe18AudioStreamBuilder17isAAudioSupportedEv"]
    pub fn oboe_AudioStreamBuilder_isAAudioSupported() -> bool;
}
extern "C" {
    #[doc = " Is the AAudio API recommended this device?"]
    #[doc = ""]
    #[doc = " AAudio may be supported but not recommended because of version specific issues."]
    #[doc = " AAudio is not recommended for Android 8.0 or earlier versions."]
    #[doc = ""]
    #[doc = " @return true if recommended"]
    #[link_name = "\u{1}_ZN4oboe18AudioStreamBuilder19isAAudioRecommendedEv"]
    pub fn oboe_AudioStreamBuilder_isAAudioRecommended() -> bool;
}
extern "C" {
    #[doc = " Create and open a stream object based on the current settings."]
    #[doc = ""]
    #[doc = " The caller owns the pointer to the AudioStream object."]
    #[doc = ""]
    #[doc = " @deprecated Use openStream(std::shared_ptr<oboe::AudioStream> &stream) instead."]
    #[doc = " @param stream pointer to a variable to receive the stream address"]
    #[doc = " @return OBOE_OK if successful or a negative error code"]
    #[link_name = "\u{1}_ZN4oboe18AudioStreamBuilder10openStreamEPPNS_11AudioStreamE"]
    pub fn oboe_AudioStreamBuilder_openStream(
        this: *mut oboe_AudioStreamBuilder,
        stream: *mut *mut oboe_AudioStream,
    ) -> oboe_Result;
}
impl oboe_AudioStreamBuilder {
    #[inline]
    pub unsafe fn isAAudioSupported() -> bool {
        oboe_AudioStreamBuilder_isAAudioSupported()
    }
    #[inline]
    pub unsafe fn isAAudioRecommended() -> bool {
        oboe_AudioStreamBuilder_isAAudioRecommended()
    }
    #[inline]
    pub unsafe fn openStream(&mut self, stream: *mut *mut oboe_AudioStream) -> oboe_Result {
        oboe_AudioStreamBuilder_openStream(self, stream)
    }
}
#[doc = " Base class for Oboe C++ audio stream."]
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct oboe_AudioStream {
    pub _bindgen_opaque_blob: [u64; 15usize],
}
#[test]
fn bindgen_test_layout_oboe_AudioStream() {
    assert_eq!(
        ::std::mem::size_of::<oboe_AudioStream>(),
        120usize,
        concat!("Size of: ", stringify!(oboe_AudioStream))
    );
    assert_eq!(
        ::std::mem::align_of::<oboe_AudioStream>(),
        8usize,
        concat!("Alignment of ", stringify!(oboe_AudioStream))
    );
}
extern "C" {
    #[doc = " Get the number of bytes per sample. This is calculated using the sample format. For example,"]
    #[doc = " a stream using 16-bit integer samples will have 2 bytes per sample."]
    #[doc = ""]
    #[doc = " @return the number of bytes per sample."]
    #[link_name = "\u{1}_ZNK4oboe11AudioStream17getBytesPerSampleEv"]
    pub fn oboe_AudioStream_getBytesPerSample(this: *const oboe_AudioStream) -> i32;
}
extern "C" {
    #[doc = " Launch a thread that will stop the stream."]
    #[link_name = "\u{1}_ZN4oboe11AudioStream16launchStopThreadEv"]
    pub fn oboe_AudioStream_launchStopThread(this: *mut oboe_AudioStream);
}
extern "C" {
    #[doc = " @return number of frames of data currently in the buffer"]
    #[link_name = "\u{1}_ZN4oboe11AudioStream18getAvailableFramesEv"]
    pub fn oboe_AudioStream_getAvailableFrames(
        this: *mut oboe_AudioStream,
    ) -> oboe_ResultWithValue<i32>;
}
extern "C" {
    #[doc = " Wait until the stream has a minimum amount of data available in its buffer."]
    #[doc = " This can be used with an EXCLUSIVE MMAP input stream to avoid reading data too close to"]
    #[doc = " the DSP write position, which may cause glitches."]
    #[doc = ""]
    #[doc = " @param numFrames minimum frames available"]
    #[doc = " @param timeoutNanoseconds"]
    #[doc = " @return number of frames available, ErrorTimeout"]
    #[link_name = "\u{1}_ZN4oboe11AudioStream22waitForAvailableFramesEix"]
    pub fn oboe_AudioStream_waitForAvailableFrames(
        this: *mut oboe_AudioStream,
        numFrames: i32,
        timeoutNanoseconds: i64,
    ) -> oboe_ResultWithValue<i32>;
}
extern "C" {
    #[doc = " Override this to provide your own behaviour for the audio callback"]
    #[doc = ""]
    #[doc = " @param audioData container array which audio frames will be written into or read from"]
    #[doc = " @param numFrames number of frames which were read/written"]
    #[doc = " @return the result of the callback: stop or continue"]
    #[doc = ""]
    #[link_name = "\u{1}_ZN4oboe11AudioStream16fireDataCallbackEPvi"]
    pub fn oboe_AudioStream_fireDataCallback(
        this: *mut oboe_AudioStream,
        audioData: *mut ::std::os::raw::c_void,
        numFrames: ::std::os::raw::c_int,
    ) -> oboe_DataCallbackResult;
}
extern "C" {
    #[doc = " Construct an `AudioStream` using the given `AudioStreamBuilder`"]
    #[doc = ""]
    #[doc = " @param builder containing all the stream's attributes"]
    #[link_name = "\u{1}_ZN4oboe11AudioStreamC2ERKNS_18AudioStreamBuilderE"]
    pub fn oboe_AudioStream_AudioStream(
        this: *mut oboe_AudioStream,
        builder: *const oboe_AudioStreamBuilder,
    );
}
impl oboe_AudioStream {
    #[inline]
    pub unsafe fn getBytesPerSample(&self) -> i32 {
        oboe_AudioStream_getBytesPerSample(self)
    }
    #[inline]
    pub unsafe fn launchStopThread(&mut self) {
        oboe_AudioStream_launchStopThread(self)
    }
    #[inline]
    pub unsafe fn getAvailableFrames(&mut self) -> oboe_ResultWithValue<i32> {
        oboe_AudioStream_getAvailableFrames(self)
    }
    #[inline]
    pub unsafe fn waitForAvailableFrames(
        &mut self,
        numFrames: i32,
        timeoutNanoseconds: i64,
    ) -> oboe_ResultWithValue<i32> {
        oboe_AudioStream_waitForAvailableFrames(self, numFrames, timeoutNanoseconds)
    }
    #[inline]
    pub unsafe fn fireDataCallback(
        &mut self,
        audioData: *mut ::std::os::raw::c_void,
        numFrames: ::std::os::raw::c_int,
    ) -> oboe_DataCallbackResult {
        oboe_AudioStream_fireDataCallback(self, audioData, numFrames)
    }
    #[inline]
    pub unsafe fn new(builder: *const oboe_AudioStreamBuilder) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        oboe_AudioStream_AudioStream(__bindgen_tmp.as_mut_ptr(), builder);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " Close the stream and deallocate any resources from the open() call."]
    #[link_name = "\u{1}_ZN4oboe11AudioStream5closeEv"]
    pub fn oboe_AudioStream_close(this: *mut ::std::os::raw::c_void) -> oboe_Result;
}
extern "C" {
    #[doc = " Start the stream. This will block until the stream has been started, an error occurs"]
    #[doc = " or `timeoutNanoseconds` has been reached."]
    #[link_name = "\u{1}_ZN4oboe11AudioStream5startEx"]
    pub fn oboe_AudioStream_start(
        this: *mut ::std::os::raw::c_void,
        timeoutNanoseconds: i64,
    ) -> oboe_Result;
}
extern "C" {
    #[doc = " Pause the stream. This will block until the stream has been paused, an error occurs"]
    #[doc = " or `timeoutNanoseconds` has been reached."]
    #[link_name = "\u{1}_ZN4oboe11AudioStream5pauseEx"]
    pub fn oboe_AudioStream_pause(
        this: *mut ::std::os::raw::c_void,
        timeoutNanoseconds: i64,
    ) -> oboe_Result;
}
extern "C" {
    #[doc = " Flush the stream. This will block until the stream has been flushed, an error occurs"]
    #[doc = " or `timeoutNanoseconds` has been reached."]
    #[link_name = "\u{1}_ZN4oboe11AudioStream5flushEx"]
    pub fn oboe_AudioStream_flush(
        this: *mut ::std::os::raw::c_void,
        timeoutNanoseconds: i64,
    ) -> oboe_Result;
}
extern "C" {
    #[doc = " Stop the stream. This will block until the stream has been stopped, an error occurs"]
    #[doc = " or `timeoutNanoseconds` has been reached."]
    #[link_name = "\u{1}_ZN4oboe11AudioStream4stopEx"]
    pub fn oboe_AudioStream_stop(
        this: *mut ::std::os::raw::c_void,
        timeoutNanoseconds: i64,
    ) -> oboe_Result;
}
extern "C" {
    #[doc = " The number of audio frames written into the stream."]
    #[doc = " This monotonic counter will never get reset."]
    #[doc = ""]
    #[doc = " @return the number of frames written so far"]
    #[link_name = "\u{1}_ZN4oboe11AudioStream16getFramesWrittenEv"]
    pub fn oboe_AudioStream_getFramesWritten(this: *mut ::std::os::raw::c_void) -> i64;
}
extern "C" {
    #[doc = " The number of audio frames read from the stream."]
    #[doc = " This monotonic counter will never get reset."]
    #[doc = ""]
    #[doc = " @return the number of frames read so far"]
    #[link_name = "\u{1}_ZN4oboe11AudioStream13getFramesReadEv"]
    pub fn oboe_AudioStream_getFramesRead(this: *mut ::std::os::raw::c_void) -> i64;
}
extern "C" {
    #[doc = " Get the estimated time that the frame at `framePosition` entered or left the audio processing"]
    #[doc = " pipeline."]
    #[doc = ""]
    #[doc = " This can be used to coordinate events and interactions with the external environment, and to"]
    #[doc = " estimate the latency of an audio stream. An example of usage can be found in the hello-oboe"]
    #[doc = " sample (search for \"calculateCurrentOutputLatencyMillis\")."]
    #[doc = ""]
    #[doc = " The time is based on the implementation's best effort, using whatever knowledge is available"]
    #[doc = " to the system, but cannot account for any delay unknown to the implementation."]
    #[doc = ""]
    #[doc = " @param clockId the type of clock to use e.g. CLOCK_MONOTONIC"]
    #[doc = " @return a FrameTimestamp containing the position and time at which a particular audio frame"]
    #[doc = " entered or left the audio processing pipeline, or an error if the operation failed."]
    #[link_name = "\u{1}_ZN4oboe11AudioStream12getTimestampEi"]
    pub fn oboe_AudioStream_getTimestamp(
        this: *mut ::std::os::raw::c_void,
        arg1: clockid_t,
    ) -> oboe_ResultWithValue<oboe_FrameTimestamp>;
}
extern "C" {
    #[doc = " Wait for a transition from one state to another."]
    #[doc = " @return OK if the endingState was observed, or ErrorUnexpectedState"]
    #[doc = "   if any state that was not the startingState or endingState was observed"]
    #[doc = "   or ErrorTimeout."]
    #[link_name = "\u{1}_ZN4oboe11AudioStream22waitForStateTransitionENS_11StreamStateES1_x"]
    pub fn oboe_AudioStream_waitForStateTransition(
        this: *mut ::std::os::raw::c_void,
        startingState: oboe_StreamState,
        endingState: oboe_StreamState,
        timeoutNanoseconds: i64,
    ) -> oboe_Result;
}
#[doc = " This struct is a stateless functor which closes an AudioStream prior to its deletion."]
#[doc = " This means it can be used to safely delete a smart pointer referring to an open stream."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct oboe_StreamDeleterFunctor {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_oboe_StreamDeleterFunctor() {
    assert_eq!(
        ::std::mem::size_of::<oboe_StreamDeleterFunctor>(),
        1usize,
        concat!("Size of: ", stringify!(oboe_StreamDeleterFunctor))
    );
    assert_eq!(
        ::std::mem::align_of::<oboe_StreamDeleterFunctor>(),
        1usize,
        concat!("Alignment of ", stringify!(oboe_StreamDeleterFunctor))
    );
}
#[doc = " LatencyTuner can be used to dynamically tune the latency of an output stream."]
#[doc = " It adjusts the stream's bufferSize by monitoring the number of underruns."]
#[doc = ""]
#[doc = " This only affects the latency associated with the first level of buffering that is closest"]
#[doc = " to the application. It does not affect low latency in the HAL, or touch latency in the UI."]
#[doc = ""]
#[doc = " Call tune() right before returning from your data callback function if using callbacks."]
#[doc = " Call tune() right before calling write() if using blocking writes."]
#[doc = ""]
#[doc = " If you want to see the ongoing results of this tuning process then call"]
#[doc = " stream->getBufferSize() periodically."]
#[doc = ""]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct oboe_LatencyTuner {
    pub _bindgen_opaque_blob: [u32; 9usize],
}
pub const oboe_LatencyTuner_State_Idle: oboe_LatencyTuner_State = 0;
pub const oboe_LatencyTuner_State_Active: oboe_LatencyTuner_State = 1;
pub const oboe_LatencyTuner_State_AtMax: oboe_LatencyTuner_State = 2;
pub const oboe_LatencyTuner_State_Unsupported: oboe_LatencyTuner_State = 3;
pub type oboe_LatencyTuner_State = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_oboe_LatencyTuner() {
    assert_eq!(
        ::std::mem::size_of::<oboe_LatencyTuner>(),
        36usize,
        concat!("Size of: ", stringify!(oboe_LatencyTuner))
    );
    assert_eq!(
        ::std::mem::align_of::<oboe_LatencyTuner>(),
        4usize,
        concat!("Alignment of ", stringify!(oboe_LatencyTuner))
    );
}
extern "C" {
    #[doc = " Adjust the bufferSizeInFrames to optimize latency."]
    #[doc = " It will start with a low latency and then raise it if an underrun occurs."]
    #[doc = ""]
    #[doc = " Latency tuning is only supported for AAudio."]
    #[doc = ""]
    #[doc = " @return OK or negative error, ErrorUnimplemented for OpenSL ES"]
    #[link_name = "\u{1}_ZN4oboe12LatencyTuner4tuneEv"]
    pub fn oboe_LatencyTuner_tune(this: *mut oboe_LatencyTuner) -> oboe_Result;
}
extern "C" {
    #[doc = " This may be called from another thread. Then tune() will call reset(),"]
    #[doc = " which will lower the latency to the minimum and then allow it to rise back up"]
    #[doc = " if there are glitches."]
    #[doc = ""]
    #[doc = " This is typically called in response to a user decision to minimize latency. In other words,"]
    #[doc = " call this from a button handler."]
    #[link_name = "\u{1}_ZN4oboe12LatencyTuner12requestResetEv"]
    pub fn oboe_LatencyTuner_requestReset(this: *mut oboe_LatencyTuner);
}
extern "C" {
    #[doc = " @return true if the audio stream's buffer size is at the maximum value. If no maximum value"]
    #[doc = " was specified when constructing the LatencyTuner then the value of"]
    #[doc = " stream->getBufferCapacityInFrames is used"]
    #[link_name = "\u{1}_ZN4oboe12LatencyTuner21isAtMaximumBufferSizeEv"]
    pub fn oboe_LatencyTuner_isAtMaximumBufferSize(this: *mut oboe_LatencyTuner) -> bool;
}
extern "C" {
    #[doc = " Construct a new LatencyTuner object which will act on the given audio stream"]
    #[doc = ""]
    #[doc = " @param stream the stream who's latency will be tuned"]
    #[link_name = "\u{1}_ZN4oboe12LatencyTunerC1ERNS_11AudioStreamE"]
    pub fn oboe_LatencyTuner_LatencyTuner(
        this: *mut oboe_LatencyTuner,
        stream: *mut oboe_AudioStream,
    );
}
extern "C" {
    #[doc = " Construct a new LatencyTuner object which will act on the given audio stream."]
    #[doc = ""]
    #[doc = " @param stream the stream who's latency will be tuned"]
    #[doc = " @param the maximum buffer size which the tune() operation will set the buffer size to"]
    #[link_name = "\u{1}_ZN4oboe12LatencyTunerC1ERNS_11AudioStreamEi"]
    pub fn oboe_LatencyTuner_LatencyTuner1(
        this: *mut oboe_LatencyTuner,
        stream: *mut oboe_AudioStream,
        maximumBufferSize: i32,
    );
}
impl oboe_LatencyTuner {
    #[inline]
    pub unsafe fn tune(&mut self) -> oboe_Result {
        oboe_LatencyTuner_tune(self)
    }
    #[inline]
    pub unsafe fn requestReset(&mut self) {
        oboe_LatencyTuner_requestReset(self)
    }
    #[inline]
    pub unsafe fn isAtMaximumBufferSize(&mut self) -> bool {
        oboe_LatencyTuner_isAtMaximumBufferSize(self)
    }
    #[inline]
    pub unsafe fn new(stream: *mut oboe_AudioStream) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        oboe_LatencyTuner_LatencyTuner(__bindgen_tmp.as_mut_ptr(), stream);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(stream: *mut oboe_AudioStream, maximumBufferSize: i32) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        oboe_LatencyTuner_LatencyTuner1(__bindgen_tmp.as_mut_ptr(), stream, maximumBufferSize);
        __bindgen_tmp.assume_init()
    }
}
pub const oboe_LatencyTuner_kIdleCount: i32 = 8;
pub const oboe_LatencyTuner_kDefaultNumBursts: i32 = 2;
extern "C" {
    #[doc = " Return the version of the SDK that is currently running."]
    #[doc = ""]
    #[doc = " For example, on Android, this would return 27 for Oreo 8.1."]
    #[doc = " If the version number cannot be determined then this will return -1."]
    #[doc = ""]
    #[doc = " @return version number or -1"]
    #[link_name = "\u{1}_ZN4oboe13getSdkVersionEv"]
    pub fn oboe_getSdkVersion() -> ::std::os::raw::c_int;
}
#[doc = " Oboe versioning object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct oboe_Version {
    pub _address: u8,
}
pub const oboe_Version_Major: u8 = 1;
pub const oboe_Version_Minor: u8 = 5;
pub const oboe_Version_Patch: u16 = 0;
pub const oboe_Version_Text: &'static [u8; 6usize] = b"1.5.0\0";
pub const oboe_Version_Number: u32 = 17104896;
#[test]
fn bindgen_test_layout_oboe_Version() {
    assert_eq!(
        ::std::mem::size_of::<oboe_Version>(),
        1usize,
        concat!("Size of: ", stringify!(oboe_Version))
    );
    assert_eq!(
        ::std::mem::align_of::<oboe_Version>(),
        1usize,
        concat!("Alignment of ", stringify!(oboe_Version))
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct oboe_StabilizedCallback {
    pub _base: oboe_AudioStreamCallback,
    pub mCallback: *mut oboe_AudioStreamCallback,
    pub mFrameCount: i64,
    pub mEpochTimeNanos: i64,
    pub mOpsPerNano: f64,
}
#[test]
fn bindgen_test_layout_oboe_StabilizedCallback() {
    assert_eq!(
        ::std::mem::size_of::<oboe_StabilizedCallback>(),
        36usize,
        concat!("Size of: ", stringify!(oboe_StabilizedCallback))
    );
    assert_eq!(
        ::std::mem::align_of::<oboe_StabilizedCallback>(),
        4usize,
        concat!("Alignment of ", stringify!(oboe_StabilizedCallback))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<oboe_StabilizedCallback>())).mCallback as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(oboe_StabilizedCallback),
            "::",
            stringify!(mCallback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<oboe_StabilizedCallback>())).mFrameCount as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(oboe_StabilizedCallback),
            "::",
            stringify!(mFrameCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<oboe_StabilizedCallback>())).mEpochTimeNanos as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(oboe_StabilizedCallback),
            "::",
            stringify!(mEpochTimeNanos)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<oboe_StabilizedCallback>())).mOpsPerNano as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(oboe_StabilizedCallback),
            "::",
            stringify!(mOpsPerNano)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4oboe18StabilizedCallbackC1EPNS_19AudioStreamCallbackE"]
    pub fn oboe_StabilizedCallback_StabilizedCallback(
        this: *mut oboe_StabilizedCallback,
        callback: *mut oboe_AudioStreamCallback,
    );
}
impl oboe_StabilizedCallback {
    #[inline]
    pub unsafe fn new(callback: *mut oboe_AudioStreamCallback) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        oboe_StabilizedCallback_StabilizedCallback(__bindgen_tmp.as_mut_ptr(), callback);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN4oboe18StabilizedCallback12onAudioReadyEPNS_11AudioStreamEPvi"]
    pub fn oboe_StabilizedCallback_onAudioReady(
        this: *mut ::std::os::raw::c_void,
        oboeStream: *mut oboe_AudioStream,
        audioData: *mut ::std::os::raw::c_void,
        numFrames: i32,
    ) -> oboe_DataCallbackResult;
}
pub type oboe_AudioReadyHandler = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        oboeStream: *mut oboe_AudioStream,
        audioData: *mut ::std::os::raw::c_void,
        numFrames: i32,
    ) -> oboe_DataCallbackResult,
>;
pub type oboe_ErrorCloseHandler = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        oboeStream: *mut oboe_AudioStream,
        error: oboe_Result,
    ),
>;
#[repr(C)]
#[derive(Debug)]
pub struct oboe_AudioStreamCallbackWrapper {
    pub _base: oboe_AudioStreamCallback,
    pub _context: *mut ::std::os::raw::c_void,
    pub _audio_ready: oboe_AudioReadyHandler,
    pub _before_close: oboe_ErrorCloseHandler,
    pub _after_close: oboe_ErrorCloseHandler,
}
#[test]
fn bindgen_test_layout_oboe_AudioStreamCallbackWrapper() {
    assert_eq!(
        ::std::mem::size_of::<oboe_AudioStreamCallbackWrapper>(),
        24usize,
        concat!("Size of: ", stringify!(oboe_AudioStreamCallbackWrapper))
    );
    assert_eq!(
        ::std::mem::align_of::<oboe_AudioStreamCallbackWrapper>(),
        4usize,
        concat!("Alignment of ", stringify!(oboe_AudioStreamCallbackWrapper))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<oboe_AudioStreamCallbackWrapper>()))._context as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(oboe_AudioStreamCallbackWrapper),
            "::",
            stringify!(_context)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<oboe_AudioStreamCallbackWrapper>()))._audio_ready as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(oboe_AudioStreamCallbackWrapper),
            "::",
            stringify!(_audio_ready)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<oboe_AudioStreamCallbackWrapper>()))._before_close as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(oboe_AudioStreamCallbackWrapper),
            "::",
            stringify!(_before_close)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<oboe_AudioStreamCallbackWrapper>()))._after_close as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(oboe_AudioStreamCallbackWrapper),
            "::",
            stringify!(_after_close)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4oboe26AudioStreamCallbackWrapper10setContextEPv"]
    pub fn oboe_AudioStreamCallbackWrapper_setContext(
        this: *mut oboe_AudioStreamCallbackWrapper,
        context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4oboe26AudioStreamCallbackWrapperC1EPFNS_18DataCallbackResultEPvPNS_11AudioStreamES2_iEPFvS2_S4_NS_6ResultEES9_"]
    pub fn oboe_AudioStreamCallbackWrapper_AudioStreamCallbackWrapper(
        this: *mut oboe_AudioStreamCallbackWrapper,
        audio_ready: oboe_AudioReadyHandler,
        before_close: oboe_ErrorCloseHandler,
        after_close: oboe_ErrorCloseHandler,
    );
}
impl oboe_AudioStreamCallbackWrapper {
    #[inline]
    pub unsafe fn setContext(&mut self, context: *mut ::std::os::raw::c_void) {
        oboe_AudioStreamCallbackWrapper_setContext(self, context)
    }
    #[inline]
    pub unsafe fn new(
        audio_ready: oboe_AudioReadyHandler,
        before_close: oboe_ErrorCloseHandler,
        after_close: oboe_ErrorCloseHandler,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        oboe_AudioStreamCallbackWrapper_AudioStreamCallbackWrapper(
            __bindgen_tmp.as_mut_ptr(),
            audio_ready,
            before_close,
            after_close,
        );
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN4oboe26AudioStreamCallbackWrapper12onAudioReadyEPNS_11AudioStreamEPvi"]
    pub fn oboe_AudioStreamCallbackWrapper_onAudioReady(
        this: *mut ::std::os::raw::c_void,
        oboeStream: *mut oboe_AudioStream,
        audioData: *mut ::std::os::raw::c_void,
        numFrames: i32,
    ) -> oboe_DataCallbackResult;
}
extern "C" {
    #[link_name = "\u{1}_ZThn4_N4oboe26AudioStreamCallbackWrapper18onErrorBeforeCloseEPNS_11AudioStreamENS_6ResultE"]
    pub fn oboe_AudioStreamCallbackWrapper_onErrorBeforeClose(
        this: *mut ::std::os::raw::c_void,
        oboeStream: *mut oboe_AudioStream,
        error: oboe_Result,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZThn4_N4oboe26AudioStreamCallbackWrapper17onErrorAfterCloseEPNS_11AudioStreamENS_6ResultE"]
    pub fn oboe_AudioStreamCallbackWrapper_onErrorAfterClose(
        this: *mut ::std::os::raw::c_void,
        oboeStream: *mut oboe_AudioStream,
        error: oboe_Result,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4oboe30AudioStreamCallbackWrapper_newEPFNS_18DataCallbackResultEPvPNS_11AudioStreamES1_iEPFvS1_S3_NS_6ResultEES8_"]
    pub fn oboe_AudioStreamCallbackWrapper_new(
        audio_ready: oboe_AudioReadyHandler,
        before_close: oboe_ErrorCloseHandler,
        after_close: oboe_ErrorCloseHandler,
    ) -> *mut oboe_AudioStreamCallbackWrapper;
}
extern "C" {
    #[link_name = "\u{1}_ZN4oboe33AudioStreamCallbackWrapper_deleteEPNS_26AudioStreamCallbackWrapperE"]
    pub fn oboe_AudioStreamCallbackWrapper_delete(callback: *mut oboe_AudioStreamCallbackWrapper);
}
extern "C" {
    #[link_name = "\u{1}_ZN4oboe22AudioStreamBuilder_newEv"]
    pub fn oboe_AudioStreamBuilder_new() -> *mut oboe_AudioStreamBuilder;
}
extern "C" {
    #[link_name = "\u{1}_ZN4oboe25AudioStreamBuilder_deleteEPNS_18AudioStreamBuilderE"]
    pub fn oboe_AudioStreamBuilder_delete(builder: *mut oboe_AudioStreamBuilder);
}
extern "C" {
    #[link_name = "\u{1}_ZN4oboe30AudioStreamBuilder_setCallbackEPNS_18AudioStreamBuilderEPNS_26AudioStreamCallbackWrapperE"]
    pub fn oboe_AudioStreamBuilder_setCallback(
        builder: *mut oboe_AudioStreamBuilder,
        callback: *mut oboe_AudioStreamCallbackWrapper,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4oboe30AudioStreamBuilder_getAudioApiEPKNS_18AudioStreamBuilderE"]
    pub fn oboe_AudioStreamBuilder_getAudioApi(
        builder: *const oboe_AudioStreamBuilder,
    ) -> oboe_AudioApi;
}
extern "C" {
    #[link_name = "\u{1}_ZN4oboe30AudioStreamBuilder_setAudioApiEPNS_18AudioStreamBuilderENS_8AudioApiE"]
    pub fn oboe_AudioStreamBuilder_setAudioApi(
        builder: *mut oboe_AudioStreamBuilder,
        api: oboe_AudioApi,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4oboe26AudioStreamBuilder_getBaseEPNS_18AudioStreamBuilderE"]
    pub fn oboe_AudioStreamBuilder_getBase(
        builder: *mut oboe_AudioStreamBuilder,
    ) -> *mut oboe_AudioStreamBase;
}
extern "C" {
    #[link_name = "\u{1}_ZN4oboe18AudioStream_deleteEPNS_11AudioStreamE"]
    pub fn oboe_AudioStream_delete(oboeStream: *mut oboe_AudioStream);
}
extern "C" {
    #[link_name = "\u{1}_ZN4oboe16AudioStream_openEPNS_11AudioStreamE"]
    pub fn oboe_AudioStream_open(oboeStream: *mut oboe_AudioStream) -> oboe_Result;
}
extern "C" {
    #[link_name = "\u{1}_ZN4oboe24AudioStream_requestStartEPNS_11AudioStreamE"]
    pub fn oboe_AudioStream_requestStart(oboeStream: *mut oboe_AudioStream) -> oboe_Result;
}
extern "C" {
    #[link_name = "\u{1}_ZN4oboe24AudioStream_requestPauseEPNS_11AudioStreamE"]
    pub fn oboe_AudioStream_requestPause(oboeStream: *mut oboe_AudioStream) -> oboe_Result;
}
extern "C" {
    #[link_name = "\u{1}_ZN4oboe24AudioStream_requestFlushEPNS_11AudioStreamE"]
    pub fn oboe_AudioStream_requestFlush(oboeStream: *mut oboe_AudioStream) -> oboe_Result;
}
extern "C" {
    #[link_name = "\u{1}_ZN4oboe23AudioStream_requestStopEPNS_11AudioStreamE"]
    pub fn oboe_AudioStream_requestStop(oboeStream: *mut oboe_AudioStream) -> oboe_Result;
}
extern "C" {
    #[link_name = "\u{1}_ZN4oboe20AudioStream_getStateEPKNS_11AudioStreamE"]
    pub fn oboe_AudioStream_getState(oboeStream: *const oboe_AudioStream) -> oboe_StreamState;
}
extern "C" {
    #[link_name = "\u{1}_ZN4oboe30AudioStream_waitForStateChangeEPNS_11AudioStreamENS_11StreamStateEPS2_x"]
    pub fn oboe_AudioStream_waitForStateChange(
        oboeStream: *mut oboe_AudioStream,
        inputState: oboe_StreamState,
        nextState: *mut oboe_StreamState,
        timeoutNanoseconds: i64,
    ) -> oboe_Result;
}
extern "C" {
    #[link_name = "\u{1}_ZN4oboe33AudioStream_setBufferSizeInFramesEPNS_11AudioStreamEi"]
    pub fn oboe_AudioStream_setBufferSizeInFrames(
        oboeStream: *mut oboe_AudioStream,
        requestedFrames: i32,
    ) -> oboe_ResultWithValue<i32>;
}
extern "C" {
    #[link_name = "\u{1}_ZN4oboe24AudioStream_getXRunCountEPKNS_11AudioStreamE"]
    pub fn oboe_AudioStream_getXRunCount(
        oboeStream: *const oboe_AudioStream,
    ) -> oboe_ResultWithValue<i32>;
}
extern "C" {
    #[link_name = "\u{1}_ZN4oboe32AudioStream_isXRunCountSupportedEPKNS_11AudioStreamE"]
    pub fn oboe_AudioStream_isXRunCountSupported(oboeStream: *const oboe_AudioStream) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN4oboe29AudioStream_getFramesPerBurstEPNS_11AudioStreamE"]
    pub fn oboe_AudioStream_getFramesPerBurst(oboeStream: *mut oboe_AudioStream) -> i32;
}
extern "C" {
    #[link_name = "\u{1}_ZN4oboe34AudioStream_calculateLatencyMillisEPNS_11AudioStreamE"]
    pub fn oboe_AudioStream_calculateLatencyMillis(
        oboeStream: *mut oboe_AudioStream,
    ) -> oboe_ResultWithValue<f64>;
}
extern "C" {
    #[link_name = "\u{1}_ZN4oboe23AudioStream_getAudioApiEPKNS_11AudioStreamE"]
    pub fn oboe_AudioStream_getAudioApi(oboeStream: *const oboe_AudioStream) -> oboe_AudioApi;
}
extern "C" {
    #[link_name = "\u{1}_ZN4oboe16AudioStream_readEPNS_11AudioStreamEPvix"]
    pub fn oboe_AudioStream_read(
        oboeStream: *mut oboe_AudioStream,
        buffer: *mut ::std::os::raw::c_void,
        numFrames: i32,
        timeoutNanoseconds: i64,
    ) -> oboe_ResultWithValue<i32>;
}
extern "C" {
    #[link_name = "\u{1}_ZN4oboe17AudioStream_writeEPNS_11AudioStreamEPKvix"]
    pub fn oboe_AudioStream_write(
        oboeStream: *mut oboe_AudioStream,
        buffer: *const ::std::os::raw::c_void,
        numFrames: i32,
        timeoutNanoseconds: i64,
    ) -> oboe_ResultWithValue<i32>;
}
extern "C" {
    #[link_name = "\u{1}_ZN4oboe19AudioStream_getBaseEPNS_11AudioStreamE"]
    pub fn oboe_AudioStream_getBase(oboeStream: *mut oboe_AudioStream)
        -> *mut oboe_AudioStreamBase;
}
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __clockid_t = __kernel_clockid_t;
pub type clockid_t = __clockid_t;
#[test]
fn __bindgen_test_layout_oboe_ResultWithValue_open0_int32_t_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<oboe_ResultWithValue<i32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(oboe_ResultWithValue<i32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<oboe_ResultWithValue<i32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(oboe_ResultWithValue<i32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_oboe_ResultWithValue_open0_int32_t_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<oboe_ResultWithValue<i32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(oboe_ResultWithValue<i32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<oboe_ResultWithValue<i32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(oboe_ResultWithValue<i32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_oboe_ResultWithValue_open0_int32_t_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<oboe_ResultWithValue<i32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(oboe_ResultWithValue<i32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<oboe_ResultWithValue<i32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(oboe_ResultWithValue<i32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_oboe_ResultWithValue_open0_int32_t_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<oboe_ResultWithValue<i32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(oboe_ResultWithValue<i32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<oboe_ResultWithValue<i32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(oboe_ResultWithValue<i32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_oboe_ResultWithValue_open0_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<oboe_ResultWithValue<f64>>(),
        12usize,
        concat!(
            "Size of template specialization: ",
            stringify!(oboe_ResultWithValue<f64>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<oboe_ResultWithValue<f64>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(oboe_ResultWithValue<f64>)
        )
    );
}
#[test]
fn __bindgen_test_layout_oboe_ResultWithValue_open0_int32_t_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<oboe_ResultWithValue<i32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(oboe_ResultWithValue<i32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<oboe_ResultWithValue<i32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(oboe_ResultWithValue<i32>)
        )
    );
}
#[test]
fn __bindgen_test_layout_oboe_ResultWithValue_open0_int32_t_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<oboe_ResultWithValue<i32>>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(oboe_ResultWithValue<i32>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<oboe_ResultWithValue<i32>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(oboe_ResultWithValue<i32>)
        )
    );
}
